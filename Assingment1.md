Nachiket
Answer 5: A chemist tries to find a way to solve a problem. Once a solution is found, he will move on. A chemical engineer’s job is to check if the solution is scalable, reliable and fits in given budget and time.
The same analogy can be used for any science vs engineering comparison. We need exact steps to solve a problem which we can get from science. But the solution must be practical, reliable and efficient.
“Computer science is the scientific and practical approach to computation and its applications.” - https://en.wikipedia.org/wiki/Computer_science
Software engineering is building methodologies and tools to use knowledge of solving problems in computer science in practical, reliable and efficient way.

Answer 6:
a) Abstraction - Abstraction in SWE is a way of hiding complexity of a system from a client by adding a high level which takes care of complexity. The client speaks to the higher or abstract layer. It is one of the most important concepts in SWE as it compartmentalize the system and various client groups can work independently in a smaller subsystem. As abstraction hides complexity of a system, clients can’t understand overall complexity of a system. It’s harder to come to consensus while making decisions without understanding complexity, which is first essential difficulty.
b) Conversation - Conversation is very important between team members and between clients and engineers. As discussed in abstraction, all stakeholders seldom have idea of overall complexity of system. So, bad communication cause bad software, unseen delays and budget overrun. The problems in conversation comes from human unreliability which is inherent to any system and hence its essential difficulty.
c) Specification - Abstraction and conversation talks about methodologies of solving complexity of a problem. But all the stakeholders must conform to what they want to build. Specification is reliable description of a software system. A specification can only be as good as understanding complexity of a system. As human beings, we have problems in proper specifications. So this problem is inherent to any system and hence is essential difficulty.
d) Translation - Translation is the process of implementing the specifications into solution. Once the specification and communication is over, engineers have to implement the solution, trying various methodologies, and they test their solution extensively. There can be multiple ways to solve a solution and problems can arise even after good specification because of choosing one solution or methodology over another. Hence, translation faces accidental difficulties.
e) Iteration - Iteration is process of designing a system, get feedback and make changes to reflect in a new design, repeatedly until we can come to desirable state. As we may know by now, it is hard to understand complexity of a system for all stakeholders. So, most times it's easier to build the basic system first and ask the clients if it is the product that they want. As the clients give feedback, the engineers can add new complexity iteratively. As clients conform to each complexity in the process, there is less chance for miscommunication or misspecification. Iteration is very powerful tool as it tries to tackle biggest problem in software engineering, the complexity of a system.

Answer 3: Essential difficulties according to Brooks are the ones that are inherent to the software domain. He states 4 main essential difficulties i.e. Complexity, Conformity, Invisibility and Changeability.
Complexity: Software as a whole is a thought put in hardware. As the time immemorial, different engineering streams build tangible things like cars, bridges, buildings etc which if we try to modify after construction will cost a lot. But that's not the case with software, it’s extensively malleable. Like as when the hardware gets better and advanced, it forces the software to keep-up with it and change. For example as the touch-screens got famous in mobiles, it forced the laptop industry to incorporate them and the Operating System companies to incorporate the functionalities of touch-screen. Similarly, changes in law, the user domain and extension of application functionality are other aspects that force the Software to change. A good example of user forced extension of application functionality is emails. Initially emails were made just to communicate over internet with text messages. But as the users started using it, they called out for more functionalities like integrated folders to filter the messages, integrated chats etc.
Conformity: Software is the newest engineering sector and is conceived as the one which should yield the most with other engineering sectors. Adding to this it also faces the arbitrary complexity. This complexity exists as different people working on different interfaces have different ways to solve a problem and design an algorithm. And hence a software must conform to the various designs and methods. For example, while building a software, the team of engineers have to conform that their methods and algorithms are in sync with each other. Similarly, when a new member joins the team, he will have to spend time to understand the current methods before he starts building his own.
Complexity: This is one of the most inherent essential difficulties in Software Engineering. Software Engineering unlike other engineering domains never have 2 parts same. And hence  when we try to scale up our software it’s not just repeating it over and over again but to add new functionalities, change the existing code to be able to perform better, redefine the existing functions to comply with new requirements etc. Making all these changes bring with them the problem of communication, understanding the code and hence give rise to unreliable software states. For example, if a person creates a functionality and doesn’t provide proper comments and documentation, then if a new person wants to reuse that code or build a functionality on top of the existing one, due to his limited knowledge available about the product, he might not understand all the use cases and boundary conditions of the existing product and will end up adding bugs to the existing product also.
Invisibility: Software systems are not tangible like automobiles or buildings. It’s very difficult for a software engineer to comprehend a software’s complexity, its different components and how they interact. If someone even tries to build a visual of the software, the visual will end up being multi-dimensional having a number of graphs in it which will hardly solve the purpose. For example, a website has different components like cache, database, server code, front-end code  























































Chaitra

Define the term essential difficulties as it is used by Brooks. Provide background and context with your answer and at least one example of an essential difficulty.

Brooks has defined essential difficulties as those difficulties that are inherent in the nature of software. According to him, the essence of a software entity lies in construction of concepts like data sets, relationship among these data items, algorithms, functions etc. that are closely interlinked with each other and these are abstract concepts that are highly precise and richly detailed. Hence the hard part of building a software lies in specification, design, and testing of these conceptual constructs. He calls these intrinsic difficulties as essential difficulties involved in developing a software entity.

Let us take an example of managing a server remotely using a software application. Remote management of servers will involve complex embedded systems that will constantly monitor the server and software applications for such systems have to be designed and developed in such a way that they will have to access the data from these embedded systems and use these data to monitor and manage the servers remotely. The development of this software has inherent difficulties. A detailed architecture of the server has to be studied by every team member working on this project. Nothing can be done to make the problem simpler. Such difficulties that are caused by the problem to be solved are called essential complexities.

Define what Brooks means by a silver bullet and reconstruct his argument as to why he believes there is no silver bullet for software engineering.

According to Brooks, a silver bullet for software engineering is something that will make the software costs drop rapidly - a single technique or technology that by itself can deliver one order-of-magnitude improvement to some aspect of software development.

He argues that “there is no single development, in either technology or in management technique, that by itself promises even  one order-of-magnitude improvement in productivity, in reliability, in simplicity. The nature of a software entity is so complex and exhaustive that it is highly unlikely that there will be any inventions that will improve the already existing software technologies by atleast one order-of-magnitude improvement. 


